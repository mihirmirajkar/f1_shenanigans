<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Camera Lap Tracker (Local Test)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; background: #0d1117; color: #e6edf3; margin: 0; padding: 12px; text-align: center; }
    h1 { margin: 0.2em 0 0.1em; }
    .hint { color: #8b949e; font-size: 0.95rem; }
    .controls { margin: 0.5em auto 0.6em; max-width: 940px; display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
    .card { background: #161b22; border: 1px solid #30363d; border-radius: 10px; padding: 10px; }
    .car { display: grid; grid-template-columns: 1fr 90px 70px 70px; gap: 8px; align-items: center; margin: 6px 0; }
    .car input[type="text"] { width: 100%; padding: 6px 8px; background: #0d1117; color: #e6edf3; border: 1px solid #30363d; border-radius: 6px; }
    .views { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
    .views video, .views canvas { width: 48%; min-width: 260px; max-width: 940px; border-radius: 10px; border: 1px solid #30363d; background: #000; }
    video, canvas { width: 100%; max-width: 940px; border-radius: 10px; border: 1px solid #30363d; background: #000; }
    .sliders { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    label { font-size: 0.9rem; color: #c9d1d9; }
    input[type="range"] { width: 100%; }
    .val { color: #8b949e; font-family: "SF Mono", "Roboto Mono", monospace; margin-left: 6px; font-size: 0.85rem; }
    button { background: #238636; color: #fff; border: none; border-radius: 8px; padding: 10px 14px; font-weight: 700; cursor: pointer; }
    button.alt { background: #1f6feb; }
    button.small { padding: 7px 10px; font-size: 0.9rem; }
    button.warn { background: #d2553f; }
    #log { font-family: "SF Mono", "Roboto Mono", monospace; text-align: left; max-width: 940px; margin: 0.6em auto; background: #0b0f14; border: 1px solid #30363d; border-radius: 10px; padding: 10px; white-space: pre-wrap; height: 150px; overflow: auto; }
    .laps { max-width: 940px; margin: 0.6em auto; text-align: left; }
    .laps table { width: 100%; border-collapse: collapse; font-family: "SF Mono", "Roboto Mono", monospace; }
    .laps th, .laps td { padding: 6px 8px; border-bottom: 1px solid #30363d; font-size: 0.95rem; }
    .laps th { text-transform: uppercase; letter-spacing: 0.06em; color: #8b949e; }
  </style>
</head>
<body>
  <h1>Camera Lap Tracker (Local Test)</h1>
  <div class="hint">Runs fully in browser against a mocked backend. Allow camera, align the band, move colored objects through it.</div>

  <div class="controls">
    <div class="card" style="flex: 1 1 300px; min-width: 260px;">
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:6px;">
        <strong>Cars</strong>
        <input id="carCount" type="number" min="1" max="6" value="2" style="width:70px; padding:6px 8px; background:#0d1117; color:#e6edf3; border:1px solid #30363d; border-radius:6px;" />
        <button id="applyCount" class="small alt">Apply Count</button>
        <button id="saveCars" class="small">Save Names/Colors</button>
        <button id="restartRace" class="small warn">Restart Race</button>
      </div>
      <div class="hint" style="text-align:left; margin-bottom:6px;">Reorder with ↑/↓ to match start order.</div>
      <div id="carList"></div>
      <button id="resetBg" class="small warn" style="margin-top:6px;">Relearn Background</button>
    </div>
    <div class="card" style="flex: 1 1 260px; min-width: 240px;">
      <div class="sliders">
        <div>
          <label>Band Y (height %) <span id="bandYVal" class="val"></span></label>
          <input id="bandY" type="range" min="5" max="90" value="65" />
        </div>
        <div>
          <label>Band H (height %) <span id="bandHVal" class="val"></span></label>
          <input id="bandH" type="range" min="5" max="60" value="15" />
        </div>
        <div>
          <label>Sensitivity (motion px) <span id="motionPxVal" class="val"></span></label>
          <input id="motionPx" type="range" min="200" max="4000" value="900" />
        </div>
        <div>
          <label>Diff Threshold <span id="diffThrVal" class="val"></span></label>
          <input id="diffThr" type="range" min="10" max="80" value="28" />
        </div>
      </div>
    </div>
  </div>

  <div class="views">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>
  </div>

  <div style="margin: 0.5em auto 0.2em; max-width: 940px; text-align: left;" class="hint">
    Tip: allow camera on localhost, keep the finish line inside the band, and use bright, distinct sticker colors.
  </div>

  <div id="log"></div>

  <div class="laps">
    <table>
      <thead><tr><th>Car</th><th>Last Lap</th><th>Recent Laps</th></tr></thead>
      <tbody id="lapsBody"></tbody>
    </table>
  </div>

  <script>
    let carProfiles = [];
    let maxCars = 6;
    const MAX_COLOR_DISTANCE = 110;  // stricter color match threshold to reduce wrong assignments

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const logEl = document.getElementById('log');
    const lapsBody = document.getElementById('lapsBody');
    const bandY = document.getElementById('bandY');
    const bandH = document.getElementById('bandH');
    const motionPx = document.getElementById('motionPx');
    const diffThr = document.getElementById('diffThr');
    const bandYVal = document.getElementById('bandYVal');
    const bandHVal = document.getElementById('bandHVal');
    const motionPxVal = document.getElementById('motionPxVal');
    const diffThrVal = document.getElementById('diffThrVal');
    const resetBgBtn = document.getElementById('resetBg');
    const carCountInput = document.getElementById('carCount');
    const applyCountBtn = document.getElementById('applyCount');
    const saveCarsBtn = document.getElementById('saveCars');
    const restartBtn = document.getElementById('restartRace');

    const MIN_LAP_GAP_MS = 4000; // match server min lap filter

    let bgFrame = null;
    let lastGlobalHit = 0;
    let pendingCar = null;
    let pendingAt = 0;
    let pendingCount = 0;
    const CONFIRM_WINDOW_MS = 250; // require two agreeing frames within this window

    function updateSliderLabels() {
      bandYVal.textContent = `${bandY.value}%`;
      bandHVal.textContent = `${bandH.value}%`;
      motionPxVal.textContent = `${motionPx.value} px`;
      diffThrVal.textContent = diffThr.value;
    }

    function log(msg) {
      const now = new Date().toLocaleTimeString();
      logEl.textContent = `[${now}] ${msg}\n` + logEl.textContent;
    }

    function hexToRgb(hex) {
      const v = parseInt(hex.slice(1), 16);
      return { r: (v >> 16) & 255, g: (v >> 8) & 255, b: v & 255 };
    }

    function rebuildCarList() {
      const container = document.getElementById('carList');
      container.innerHTML = '';
      carProfiles.forEach((car, idx) => {
        const row = document.createElement('div');
        row.className = 'car';
        row.innerHTML = `
          <input type="text" value="${car.label}" data-idx="${idx}" />
          <input type="color" value="${car.color}" data-idx="${idx}" />
          <button class="small alt" data-idx="${idx}" data-dir="up">↑</button>
          <button class="small alt" data-idx="${idx}" data-dir="down">↓</button>
        `;
        const [nameInput, colorInput, upBtn, downBtn] = row.querySelectorAll('input, button');
        nameInput.addEventListener('input', (e) => { carProfiles[idx].label = e.target.value; });
        colorInput.addEventListener('input', (e) => { carProfiles[idx].color = e.target.value; });
        upBtn.addEventListener('click', () => moveCar(idx, -1));
        downBtn.addEventListener('click', () => moveCar(idx, 1));
        container.appendChild(row);
      });
    }

    function moveCar(index, delta) {
      const newIndex = index + delta;
      if (newIndex < 0 || newIndex >= carProfiles.length) return;
      const tmp = carProfiles[index];
      carProfiles[index] = carProfiles[newIndex];
      carProfiles[newIndex] = tmp;
      rebuildCarList();
    }

    function applyCount() {
      let desired = parseInt(carCountInput.value || '1', 10);
      if (Number.isNaN(desired)) desired = 1;
      desired = Math.min(Math.max(desired, 1), maxCars);
      carCountInput.value = desired;
      while (carProfiles.length < desired) {
        const n = carProfiles.length + 1;
        carProfiles.push({ id: `car${n}`, label: `Car ${n}`, color: '#ff4d4f', lastHit: 0, lastLapSent: 0 });
      }
      while (carProfiles.length > desired) carProfiles.pop();
      rebuildCarList();
    }

    async function saveCars() {
      const names = carProfiles.map(c => encodeURIComponent(c.label)).join(',');
      const colors = carProfiles.map(c => encodeURIComponent(c.color)).join(',');
      const body = new URLSearchParams();
      body.set('count', String(carProfiles.length));
      body.set('names', names);
      body.set('colors', colors);
      await fetch('/car_config', { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body });
      log('Saved car names/colors.');
      fetchCarStatus();
    }

    function drawBand(w, h) {
      const y = (bandY.value / 100) * h;
      const bandHeight = (bandH.value / 100) * h;
      ctx.strokeStyle = '#00ffaa';
      ctx.lineWidth = 3;
      ctx.strokeRect(0, y, w, bandHeight);
      ctx.fillStyle = 'rgba(0,255,170,0.12)';
      ctx.fillRect(0, y, w, bandHeight);
    }

    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          canvas.width = video.videoWidth || 640;
          canvas.height = video.videoHeight || 480;
          log('Camera ready. Align the band with the finish line.');
          requestAnimationFrame(loop);
        };
      } catch (e) {
        log('Camera error: ' + e.message);
      }
    }

    function processFrame() {
      const w = canvas.width;
      const h = canvas.height;
      if (!w || !h) return null;

      ctx.drawImage(video, 0, 0, w, h);

      const y = Math.max(0, Math.min(h - 1, Math.round((bandY.value / 100) * h)));
      const bandHeight = Math.max(2, Math.round((bandH.value / 100) * h));
      const bandYpx = Math.min(h - bandHeight, y);

      const img = ctx.getImageData(0, bandYpx, w, bandHeight);
      const data = img.data;

      if (!bgFrame || bgFrame.length !== data.length) {
        bgFrame = new Uint8ClampedArray(data);
        return null;
      }

      const diffLimit = Number(diffThr.value);
      let motionPixels = 0;
      let sumR = 0, sumG = 0, sumB = 0;

      const stride = 8;
      for (let i = 0; i < data.length; i += stride) {
        const dr = Math.abs(data[i] - bgFrame[i]);
        const dg = Math.abs(data[i + 1] - bgFrame[i + 1]);
        const db = Math.abs(data[i + 2] - bgFrame[i + 2]);
        const d = (dr + dg + db) / 3;
        if (d > diffLimit) {
          motionPixels++;
          sumR += data[i];
          sumG += data[i + 1];
          sumB += data[i + 2];
        }
      }

      const lerp = 0.02;
      for (let i = 0; i < data.length; i++) {
        bgFrame[i] = bgFrame[i] * (1 - lerp) + data[i] * lerp;
      }

      ctx.putImageData(img, 0, bandYpx);
      drawBand(w, h);

      return { motionPixels, bandYpx, bandHeight, w, h, avg: motionPixels ? { r: sumR / motionPixels, g: sumG / motionPixels, b: sumB / motionPixels } : null };
    }

    async function sendLap(car) {
      try {
        const res = await fetch('/lap_ping?car=' + encodeURIComponent(car.id));
        const txt = await res.text();
        log(`Lap ${car.label}: ${txt}`);
      } catch (e) {
        log('Send error: ' + e.message);
      }
    }

    function chooseCar(avgColor) {
      let best = null;
      carProfiles.forEach((car) => {
        const c = hexToRgb(car.color);
        const dist = Math.hypot(c.r - avgColor.r, c.g - avgColor.g, c.b - avgColor.b);
        if (!best || dist < best.dist) {
          best = { car, dist };
        }
      });
      return best && best.dist < MAX_COLOR_DISTANCE ? best.car : (carProfiles[0] || null);
    }

    function loop() {
      const res = processFrame();
      if (res && carProfiles.length) {
          const { motionPixels, avg } = res;
          const threshold = Number(motionPx.value);
          if (motionPixels > threshold && avg) {
            const now = performance.now();
            if (now - lastGlobalHit > 500) {
              const car = chooseCar(avg);
              if (car && now - (car.lastHit || 0) > 500 && now - (car.lastLapSent || 0) > MIN_LAP_GAP_MS) {
                if (!pendingCar || pendingCar.id !== car.id || now - pendingAt > CONFIRM_WINDOW_MS) {
                  pendingCar = car;
                  pendingAt = now;
                  pendingCount = 1;
                } else {
                  pendingCount += 1;
                  if (pendingCount >= 2) {
                    car.lastHit = now;
                    car.lastLapSent = now;
                    lastGlobalHit = now;
                    pendingCar = null;
                    pendingCount = 0;
                    log(`Motion ${motionPixels} → ${car.label}`);
                    sendLap(car);
                  }
                }
              } else {
                pendingCar = null;
                pendingCount = 0;
              }
            }
          } else {
            pendingCar = null;
            pendingCount = 0;
          }
      }
      requestAnimationFrame(loop);
    }

    async function fetchCarStatus() {
      try {
        const res = await fetch('/car_status');
        const data = await res.json();
        const tbody = lapsBody;
        tbody.innerHTML = '';
        (data.cars || []).forEach((car) => {
          const tr = document.createElement('tr');
          const last = car.lastLapMs > 0 ? car.lastLapMsFormatted : '--:--.---';
          const laps = (car.laps || []).map(ms => ms.formatted).join(', ');
          tr.innerHTML = `<td>${car.label}</td><td>${last}</td><td>${laps}</td>`;
          tbody.appendChild(tr);
        });
      } catch (e) {
        // ignore
      }
    }

    async function loadConfig() {
      const res = await fetch('/car_config');
      const data = await res.json();
      maxCars = data.maxCars || 6;
      carProfiles = (data.cars || []).map((c, idx) => ({
        id: c.id || `car${idx + 1}`,
        label: c.label || `Car ${idx + 1}`,
        color: c.color || '#ff4d4f',
        lastHit: 0,
        lastLapSent: 0,
      }));
      if (!carProfiles.length) {
        carProfiles = [{ id: 'car1', label: 'Car 1', color: '#ff4d4f', lastHit: 0, lastLapSent: 0 }];
      }
      carCountInput.max = maxCars;
      carCountInput.value = carProfiles.length;
      rebuildCarList();
    }

    async function restartRace() {
      try {
        await fetch('/reset');
        bgFrame = null;
        carProfiles.forEach(c => { c.lastHit = 0; c.lastLapSent = 0; });
        fetchCarStatus();
        log('Race reset: laps cleared.');
      } catch (e) {
        log('Reset error: ' + e.message);
      }
    }

    setInterval(fetchCarStatus, 600);
    resetBgBtn.addEventListener('click', () => { bgFrame = null; log('Background reset. Hold cars still.'); });
    applyCountBtn.addEventListener('click', applyCount);
    saveCarsBtn.addEventListener('click', () => { saveCars(); fetchCarStatus(); });
    restartBtn.addEventListener('click', restartRace);
    bandY.addEventListener('input', updateSliderLabels);
    bandH.addEventListener('input', updateSliderLabels);
    motionPx.addEventListener('input', updateSliderLabels);
    diffThr.addEventListener('input', updateSliderLabels);

    loadConfig().then(() => {
      fetchCarStatus();
      updateSliderLabels();
      startCamera();
    });
  </script>
</body>
</html>
